"use strict";(self.webpackChunkreubenliengaard_github_io=self.webpackChunkreubenliengaard_github_io||[]).push([[8350],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(t),u=r,f=m["".concat(l,".").concat(u)]||m[u]||d[u]||i;return t?o.createElement(f,a(a({ref:n},c),{},{components:t})):o.createElement(f,a({ref:n},c))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:r,a[1]=s;for(var p=2;p<i;p++)a[p]=t[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},6262:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=t(7462),r=(t(7294),t(3905));const i={sidebar_position:3},a="Carbon Dioxide",s={unversionedId:"automation/reading-rpi4-sensors-with-python/carbon-dioxide",id:"automation/reading-rpi4-sensors-with-python/carbon-dioxide",title:"Carbon Dioxide",description:"Hardware",source:"@site/docs/automation/reading-rpi4-sensors-with-python/carbon-dioxide.md",sourceDirName:"automation/reading-rpi4-sensors-with-python",slug:"/automation/reading-rpi4-sensors-with-python/carbon-dioxide",permalink:"/docs/automation/reading-rpi4-sensors-with-python/carbon-dioxide",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Car OBD Port",permalink:"/docs/automation/reading-rpi4-sensors-with-python/car-obd-port"},next:{title:"Thermocouple",permalink:"/docs/automation/reading-rpi4-sensors-with-python/thermocouple"}},l={},p=[{value:"Hardware",id:"hardware",level:3},{value:"Script",id:"script",level:3},{value:"References",id:"references",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"carbon-dioxide"},"Carbon Dioxide"),(0,r.kt)("h3",{id:"hardware"},"Hardware"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"MH-Z19B NDIR infrared gas module is a common type, small size sensor, using non-dispersive infrared (NDIR) principle to detect the existence of CO 2 in the air, with good selectivity, non-oxygen dependent and long life. Built-in temperature compensation; and it has UART output and PWM output. It is developed by the tight integration of mature infrared absorbing gas detection technology, precision optical circuit design and superior circuit design.")),(0,r.kt)("p",null,"General"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"MH-Z19B Carbon Dioxide Gas Sensor"),(0,r.kt)("li",{parentName:"ul"},"uses the principle of non-scattered infrared"),(0,r.kt)("li",{parentName:"ul"},"simultaneous serial, analog and PWM output ")),(0,r.kt)("h3",{id:"script"},"Script"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"#!/usr/bin/python3\n\nimport socket\nimport ssl\nimport sys\nimport re\nimport json\nimport os.path\nimport argparse\nfrom time import time, sleep, localtime, strftime\nfrom colorama import init as colorama_init\nfrom colorama import Fore, Back, Style\nfrom configparser import ConfigParser\nfrom unidecode import unidecode\nimport mh_z19\nimport paho.mqtt.client as mqtt\nimport sdnotify\n\nproject_name = 'MH-Z19 Raspberry MQTT Client/Daemon'\nproject_url = 'https://github.com/R4scal/mhz19-mqtt-daemon'\n\nif False:\n    # will be caught by python 2.7 to be illegal syntax\n    print('Sorry, this script requires a python3 runtime environemt.', file=sys.stderr)\n\n\n# Argparse\nparser = argparse.ArgumentParser(description=project_name, epilog='For further details see: ' + project_url)\nparser.add_argument('--config_dir', help='set directory where config.ini is located', default=sys.path[0])\nparse_args = parser.parse_args()\n\n# Intro\ncolorama_init()\nprint(Fore.GREEN + Style.BRIGHT)\nprint(project_name)\nprint('Source:', project_url)\nprint(Style.RESET_ALL)\n\n# Systemd Service Notifications - https://github.com/bb4242/sdnotify\nsd_notifier = sdnotify.SystemdNotifier()\n\n# Logging function\ndef print_line(text, error = False, warning=False, sd_notify=False, console=True):\n    timestamp = strftime('%Y-%m-%d %H:%M:%S', localtime())\n    if console:\n        if error:\n            print(Fore.RED + Style.BRIGHT + '[{}] '.format(timestamp) + Style.RESET_ALL + '{}'.format(text) + Style.RESET_ALL, file=sys.stderr)\n        elif warning:\n            print(Fore.YELLOW + '[{}] '.format(timestamp) + Style.RESET_ALL + '{}'.format(text) + Style.RESET_ALL)\n        else:\n            print(Fore.GREEN + '[{}] '.format(timestamp) + Style.RESET_ALL + '{}'.format(text) + Style.RESET_ALL)\n    timestamp_sd = strftime('%b %d %H:%M:%S', localtime())\n    if sd_notify:\n        sd_notifier.notify('STATUS={} - {}.'.format(timestamp_sd, unidecode(text)))\n\n# Eclipse Paho callbacks - http://www.eclipse.org/paho/clients/python/docs/#callbacks\ndef on_connect(client, userdata, flags, rc):\n    if rc == 0:\n        print_line('MQTT connection established', console=True, sd_notify=True)\n        print()\n    else:\n        print_line('Connection error with result code {} - {}'.format(str(rc), mqtt.connack_string(rc)), error=True)\n        #kill main thread\n        os._exit(1)\n\ndef on_publish(client, userdata, mid):\n    #print_line('Data successfully published.')\n    pass\n\n\n# Load configuration file\nconfig_dir = parse_args.config_dir\n\nconfig = ConfigParser(delimiters=('=', ))\nconfig.optionxform = str\nconfig.read([os.path.join(config_dir, 'config.ini.dist'), os.path.join(config_dir, 'config.ini')])\n\nreporting_mode = config['General'].get('reporting_method', 'homeassistant-mqtt')\ndaemon_enabled = config['Daemon'].getboolean('enabled', True)\nsleep_period = config['Daemon'].getint('period', 300)\ndetection_range = config['MH-Z19'].getint('detection_range', 5000)\n\nif reporting_mode == 'homeassistant-mqtt':\n    default_base_topic = 'homeassistant'\n\nbase_topic = config['MQTT'].get('base_topic', default_base_topic).lower()\n\n# Check configuration\nif reporting_mode not in ['homeassistant-mqtt']:\n    print_line('Configuration parameter reporting_mode set to an invalid value', error=True, sd_notify=True)\n    sys.exit(1)\n\nprint_line('Configuration accepted', console=False, sd_notify=True)\n\n# MQTT connection\nif reporting_mode in ['homeassistant-mqtt']:\n    print_line('Connecting to MQTT broker ...')\n    mqtt_client = mqtt.Client()\n    mqtt_client.on_connect = on_connect\n    mqtt_client.on_publish = on_publish\n\n    if config['MQTT'].getboolean('tls', False):\n        mqtt_client.tls_set(\n            ca_certs=config['MQTT'].get('tls_ca_cert', None),\n            keyfile=config['MQTT'].get('tls_keyfile', None),\n            certfile=config['MQTT'].get('tls_certfile', None),\n            # Auto-negotiate the highest protocol version that both the client and server support, and configure the\n            # context client-side connections. Other protocol options are deprecated\n            tls_version=ssl.PROTOCOL_TLS_CLIENT\n        )\n\n    if config['MQTT'].get('username'):\n        mqtt_client.username_pw_set(config['MQTT'].get('username'), config['MQTT'].get('password', None))\n    try:\n        mqtt_client.connect(config['MQTT'].get('hostname', 'localhost'),\n                            port=config['MQTT'].getint('port', 1883),\n                            keepalive=config['MQTT'].getint('keepalive', 60))\n    except:\n        print_line('MQTT connection error. Please check your settings in the configuration file \"config.ini\"', error=True, sd_notify=True)\n        sys.exit(1)\n    else:\n       mqtt_client.loop_start()\n       sleep(1.0) # some slack to establish the connection\n\nsd_notifier.notify('READY=1')\n\n# Initialize DHT sensor\nsensor_name = '{}_mhz19'.format(socket.gethostname()).replace(\"-\", \"_\")\nprint_line('Current sensor name is \"{}\"'.format(sensor_name).lower())\n\n# Discovery Announcement\nif reporting_mode == 'homeassistant-mqtt':\n    print_line('Announcing MH-Z19 to MQTT broker for auto-discovery ...')\n    topic_path = '{}/sensor/{}'.format(base_topic, sensor_name)\n    base_payload = {\n        \"state_topic\": \"{}/state\".format(topic_path).lower()\n    }\n    # Temperature\n    payload = dict(base_payload.items())\n    payload['unit_of_measurement'] = '\xb0C'\n    payload['value_template'] = \"{{ value_json.temperature }}\"\n    payload['name'] = \"{} Temperature\".format(sensor_name)\n    payload['device_class'] = 'temperature'\n    mqtt_client.publish('{}/{}_temperature/config'.format(topic_path, sensor_name).lower(), json.dumps(payload), 1, True)\n    # CO2\n    payload = dict(base_payload.items())\n    payload['unit_of_measurement'] = 'ppm'\n    payload['value_template'] = \"{{ value_json.co2 }}\"\n    payload['name'] = \"{} CO2\".format(sensor_name)\n    mqtt_client.publish('{}/{}_co2/config'.format(topic_path, sensor_name).lower(), json.dumps(payload), 1, True)\n    # SS\n    payload = dict(base_payload.items())\n    payload['unit_of_measurement'] = ''\n    payload['value_template'] = \"{{ value_json.SS }}\"\n    payload['name'] = \"{} SS\".format(sensor_name)\n    mqtt_client.publish('{}/{}_ss/config'.format(topic_path, sensor_name).lower(), json.dumps(payload), 1, True)\n    # UhUl\n    payload = dict(base_payload.items())\n    payload['unit_of_measurement'] = ''\n    payload['value_template'] = \"{{ value_json.UhUl }}\"\n    payload['name'] = \"{} UhUl\".format(sensor_name)\n    mqtt_client.publish('{}/{}_uhul/config'.format(topic_path, sensor_name).lower(), json.dumps(payload), 1, True)\n\n\nif detection_range == 5000:\n    mh_z19.detection_range_5000(serial_console_untouched=True)\nelif detection_range == 10000:\n    mh_z19.detection_range_10000(serial_console_untouched=True)\nelif detection_range == 2000:\n    mh_z19.detection_range_2000(serial_console_untouched=True)\nelse:\n    # Unknown detection range, setting to 5000\n    mh_z19.detection_range_5000(serial_console_untouched=True)\n\n# Sensor data retrieval and publication\nwhile True:\n   print_line('Retrieving data from MH-Z19 sensor...')\n   data = mh_z19.read_all(serial_console_untouched=True)\n   if len(data) == 0:\n      print_line('Unable to get data form sensor.', error=True, sd_notify=True)\n      print()\n      continue\n   else:\n     print_line('Result: {}'.format(json.dumps(data)))\n     if reporting_mode == 'homeassistant-mqtt':\n          print_line('Publishing to MQTT topic \"{}/sensor/{}/state\"'.format(base_topic, sensor_name).lower())\n          mqtt_client.publish('{}/sensor/{}/state'.format(base_topic, sensor_name).lower(), json.dumps(data))\n          sleep(0.5) # some slack for the publish roundtrip and callback function\n     else:\n          raise NameError('Unexpected reporting_mode.')\n     print()\n\n     print_line('Status messages published', console=False, sd_notify=True)\n\n   if daemon_enabled:\n      print_line('Sleeping ({} seconds) ...'.format(sleep_period))\n      sleep(sleep_period)\n      print()\n   else:\n      print_line('Execution finished in non-daemon-mode', sd_notify=True)\n      break\n")),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Infrared_spectroscopy"},"Wikipedia"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.winsen-sensor.com/sensors/co2-sensor/mh-z19b.html"},"Winsen-Sensors"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/R4scal/mhz19-mqtt-daemon"},"Code")))}m.isMDXComponent=!0}}]);