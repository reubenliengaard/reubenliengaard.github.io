"use strict";(self.webpackChunkreubenliengaard_github_io=self.webpackChunkreubenliengaard_github_io||[]).push([[3988],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),f=r,h=p["".concat(s,".").concat(f)]||p[f]||d[f]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7561:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},i="Flood risk",l={unversionedId:"geospatial-analysis/postgis-data-management-and-queries/query-flood-risk",id:"geospatial-analysis/postgis-data-management-and-queries/query-flood-risk",title:"Flood risk",description:"To calculate flood risk from LiDAR data in PostGIS, you will need to follow these steps:",source:"@site/docs/geospatial-analysis/postgis-data-management-and-queries/query-flood-risk.md",sourceDirName:"geospatial-analysis/postgis-data-management-and-queries",slug:"/geospatial-analysis/postgis-data-management-and-queries/query-flood-risk",permalink:"/docs/geospatial-analysis/postgis-data-management-and-queries/query-flood-risk",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"PostGIS Data Management and Queries",permalink:"/docs/category/postgis-data-management-and-queries"},next:{title:"Land registry price paid parcels",permalink:"/docs/geospatial-analysis/postgis-data-management-and-queries/query-price-paid-parcels"}},s={},c=[{value:"References",id:"references",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"flood-risk"},"Flood risk"),(0,r.kt)("p",null,"To calculate flood risk from LiDAR data in PostGIS, you will need to follow these steps:"),(0,r.kt)("p",null,"Import the LiDAR data into PostGIS. This can be done using the ST_LASToSQL function, which will convert the LiDAR data into a format that can be stored in a PostGIS database."),(0,r.kt)("p",null,'Use the ST_Union function to merge all of the LiDAR points into a single geometry. This will create a "point cloud" representation of the terrain.'),(0,r.kt)("p",null,"Use the ST_Triangulate function to triangulate the point cloud. This will create a set of triangular facets, each of which represents a portion of the terrain surface."),(0,r.kt)("p",null,"Use the ST_Dump function to extract the individual triangles from the triangulated surface."),(0,r.kt)("p",null,"Use the ST_Z function to extract the elevation of each vertex of each triangle."),(0,r.kt)("p",null,"Use the ST_Area function to calculate the area of each triangle."),(0,r.kt)("p",null,"Use the ST_Centroid function to calculate the centroid of each triangle."),(0,r.kt)("p",null,"Use the ST_Distance function to calculate the distance from the centroid of each triangle to the nearest river or stream."),(0,r.kt)("p",null,"Use the elevation and distance information to calculate the flood risk for each triangle."),(0,r.kt)("p",null,"Use the ST_Union function to merge all of the triangles into a single polygon, and use the ST_ConvexHull function to create a convex hull around the polygon."),(0,r.kt)("p",null,"Use the ST_Intersection function to calculate the intersection between the convex hull and the floodplain."),(0,r.kt)("p",null,"Use the ST_Area function to calculate the area of the intersection, and use this value to calculate the overall flood risk for the region."),(0,r.kt)("h2",{id:"references"},"References"))}p.isMDXComponent=!0}}]);